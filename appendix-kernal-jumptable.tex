\chapter{KERNAL Jump Table}
\label{cha:kernal-jump-table}

\section{Using the KERNAL Jump Table}

The \emph{KERNAL} is the centerpiece of the MEGA65 operating system. It is responsible for setting up the operating system when the computer is switched on or reset, interfacing with peripherals, invoking disk operations, managing input and output streams, and driving key features of the screen editor and BASIC. While it is running, the KERNAL owns the CPU memory map and interrupt handlers, and reserves regions of memory to support its features.

The KERNAL provides an \emph{Application Programming Interface} (API) so that machine code programs can take advantage of its features, such as to read a file from disk, by calling subroutines. A program accesses these subroutines by calling addresses in a \emph{jump table}, a region of ROM code that is guaranteed by the API to always access the same subroutines in the same way, even across different versions of the ROM code. The program uses \texttt{jsr} or \texttt{jmp} (as required by the routine) using the jump table address as an absolute target. Memory at the jump table address contains a \texttt{jmp} instruction to the appropriate internal address.

For example, to write a character to the output stream (the screen terminal, by default), a program sets the accumulator (A) register to the PETSCII code to write, then calls the CHROUT subroutine with the jump table address \$FFD2:

\begin{asmcode}
    lda #$41
    jsr $ffd2
\end{asmcode}

\subsection{Prerequisites of Jump Table Routines}

All KERNAL jump table routines expect the following conditions to be true when called:

\begin{enumerate}
\item The 16-bit address range \$E000 -- \$FFFF must be mapped to the KERNAL ROM at 3.E000 -- 3.FFFF.
\item The 16-bit address range \$0000 -- \$1FFF must be mapped to KERNAL internal variable memory at 0.0000 -- 0.1FFF.
\item The CPU base page register (B) must be \$00.
\end{enumerate}

Some jump table routines have additional prerequisites. See the reference below.

The KERNAL BASIC and SYS memory maps maintain these conditions by default. If a machine code program does not change the MAP or B registers, it can call KERNAL jump table routines without additional set-up.

\subsection{History and Compatibility}

The MEGA65 KERNAL jump table is based on, and compatible with, the Commodore 65 jump table. This API is derived from, but \emph{not} entirely compatible with, the KERNAL APIs of the Commodore 64 and Commodore 128.

This documentation adopts the names of the routines from Commodore 65 documentation where possible, and invents unique names for routines new to the MEGA65. A routine with a name similar to C64 or C128 documentation may \emph{not} be API compatible. Differences are noted in this reference, where known.

The MEGA65's ``GO64'' mode uses the C64 KERNAL. Refer to a C64 programming reference for information on how to use the C64 KERNAL.

For a complete history of the KERNAL jump table across all Commodore computers, see: \url{https://www.pagetable.com/?p=926}

\newpage
\section{MEGA65 KERNAL Jump Table Quick Reference}

The following is a quick reference for the MEGA65 KERNAL jump table, in address order. See the full reference for details and examples.

\begin{longtable}{|L{2cm}|p{2cm}|L{7cm}|}
\hline
\textbf{Address} & \textbf{Name} & \textbf{Description} \\
\hline
\endfirsthead
\multicolumn{3}{l@{}}{\ldots continued}\\
\hline
\textbf{Address} & \textbf{Name} & \textbf{Description} \\
\hline
\endhead
\multicolumn{3}{l@{}}{continued \ldots}\\
\endfoot
\hline
\endlastfoot

\$FF4D & SPIN\_SPOUT & Set up fast serial ports \\
\hline
\$FF50 & CLOSE\_ALL & Close all files on a device \\
\hline
\$FF53 & C64MODE & Reset to GO64 mode \\
\hline
\$FF56 & MonitorCall & Invoke monitor \\
\hline
\$FF59 & BOOT\_SYS & Boot an alternate system from disk \\
\hline
\$FF5C & PHOENIX & Call cartridge cold start or disk boot loader \\
\hline
\$FF5F & LKUPLA & Search for logical file number in use \\
\hline
\$FF62 & LKUPSA & Search for secondary address in use \\
\hline
\$FF65 & SWAPPER & Toggle between 40x25 and 80x25 text modes / ``swap to alternate display device'' \\
\hline
\$FF68 & PFKEY & Program an editor function key \\
\hline
\$FF6B & SETBNK & Set bank for I/O and filename memory \\
\hline
\$FF6E & JSRFAR & Call subroutine in any bank \\
\hline
\$FF71 & JMPFAR & Jump to address in any bank \\
\hline
\$FF74 & LDA\_FAR & Read a byte from an address in any bank \\
\hline
\$FF77 & STA\_FAR & Store a byte to an address in any bank \\
\hline
\$FF7A & CMP\_FAR & Compare a byte with an address in any bank \\
\hline
\$FF7D & PRIMM & Print an inline null-terminated short string \\
\hline
\$FF81 & CINT & Initialize screen editor \\
\hline
\$FF84 & IOINIT & Initialize I/O devices \\
\hline
\$FF87 & RAMTAS & Initialize RAM and buffers \\
\hline
\$FF8A & RESTOR & Initialize KERNAL vector table \\
\hline
\$FF8D & VECTOR & Read/set KERNAL vector table \\
\hline
\$FF90 & SETMSG & Enable/disable KERNAL messages \\
\hline
\$FF93 & SECND & Serial: send secondary address to listener \\
\hline
\$FF96 & TKSA & Serial: send secondary address to talker \\
\hline
\$FF99 & MEMTOP & Read/set top of system RAM \\
\hline
\$FF9C & MEMBOT & Read/set bottom of system RAM \\
\hline
\$FF9F & KEY & Scan keyboard \\
\hline
\$FFA2 & MONEXIT & Monitor's exit to BASIC \\
\hline
\$FFA5 & ACPTR & Serial: accept a byte from talker \\
\hline
\$FFA8 & CIOUT & Serial: send a byte to listener \\
\hline
\$FFAB & UNTLK & Serial: send ``untalk'' command (see CLRCH) \\
\hline
\$FFAE & UNLSN & Serial: send ``unlisten'' command (see CLRCH) \\
\hline
\$FFB1 & LISTN & Serial: send ``listen'' command (see CKOUT) \\
\hline
\$FFB4 & TALK & Serial: send ``talk'' command (see CHKIN) \\
\hline
\$FFB7 & READSS & Get status of last I/O operation \\
\hline
\$FFBA & SETLFS & Set file, device, secondary address \\
\hline
\$FFBD & SETNAM & Set filename pointers \\
\hline
\$FFC0 & OPEN & Open logical file \\
\hline
\$FFC3 & CLOSE & Close logical file \\
\hline
\$FFC6 & CHKIN & Set input channel \\
\hline
\$FFC9 & CKOUT & Set output channel \\
\hline
\$FFCC & CLRCH & Restore default channels \\
\hline
\$FFCF & BASIN & Read a character from input device \\
\hline
\$FFD2 & BSOUT & Write a character to output device \\
\hline
\$FFD5 & LOAD & Load/verify from file \\
\hline
\$FFD8 & SAVE & Save to file \\
\hline
\$FFDB & SETTIM & Set CIA1 24-hour clock \\
\hline
\$FFDE & RDTIM & Read CIA1 24-hour clock \\
\hline
\$FFE1 & STOP & Report Stop key (see ScanStopKey) \\
\hline
\$FFE4 & GETIN & Read a character from input device, buffered \\
\hline
\$FFE7 & CLALL & Close all files and channels \\
\hline
\$FFEA & ScanStopKey & Scan Stop key \\
\hline
\$FFED & SCRORG & Get current screen window size \\
\hline
\$FFF0 & PLOT & Read/set cursor position \\
\hline
\$FFF3 & IOBASE & Report base address of I/O block \\
\hline
\end{longtable}


\newpage
\section{MEGA65 KERNAL Jump Table Reference}
\titleformat*{\subsection}{\normalfont\huge\bfseries\color{blue}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% ****
% ACPTR
% ****

\newpage
\subsection{ACPTR}
\index{KERNAL Jump Table!ACPTR}
\label{KERNAL Jump Table!ACPTR}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FFA5
    \item [Description:] Serial: accept a byte from talker
    \item [Inputs:]
    \item [Outputs:]
    \item [Remarks:]
    \item [Example:]
\end{description}


% ****
% BASIN
% ****

\newpage
\subsection{BASIN}
\index{KERNAL Jump Table!BASIN}
\label{KERNAL Jump Table!BASIN}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FFCF
    \item [Description:] Read a character from input device
    \item [Inputs:]
    \item [Outputs:]
    \item [Remarks:]
    \item [Example:]
\end{description}


% ****
% BOOT\_SYS
% ****

\newpage
\subsection{BOOT{\_}SYS}
\index{KERNAL Jump Table!BOOT_SYS}
\label{KERNAL Jump Table!BOOT_SYS}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JMP \$FF59
    \item [Description:] Boot an alternate system from disk
    \item [Remarks:]
        The Commodore 65 intended a feature where a floppy disk in the internal 3-1/2" disk drive could bootstrap software using up to 512 bytes of machine code in a ``home'' sector, at track 0, sector 1.

        When the BOOT\_SYS KERNAL routine is called, or the user performs the \textbf{BOOT SYS} command, or the user holds the Alt key during start-up, the KERNAL reads the home sector of the disk. If the first byte is \$4C, the KERNAL loads the sector into memory at 0.0400, then invokes it with JMP. If no disk is present or the first byte is not \$4C, no action is taken.

        The boot sector feature is distinct from the BASIC 10 \textbf{BOOT} command that loads and runs a file named \texttt{AUTOBOOT.C65}. It is not compatible with C128-style boot sectors.

        This routine does not return. Only use JMP with this routine.

        \underline{NOTE}: For the MEGA65, this feature is untested.
    \item [Example:]
        \begin{asmcode}
boot_sys = $ff59

    jmp $ff59
        \end{asmcode}

\end{description}


% ****
% BSOUT
% ****

\newpage
\subsection{BSOUT}
\index{KERNAL Jump Table!BSOUT}
\label{KERNAL Jump Table!BSOUT}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FFD2
    \item [Description:] Write a character to output device
    \item [Inputs:]
    \item [Outputs:]
    \item [Remarks:]
    \item [Example:]
\end{description}


% ****
% C64MODE
% ****

\newpage
\subsection{C64MODE}
\index{KERNAL Jump Table!C64MODE}
\label{KERNAL Jump Table!C64MODE}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JMP \$FF53
    \item [Description:] Reset to GO64 mode
    \item [Remarks:]
        This switches to the GO64 mode memory map, resets the VIC modes, and jumps to the GO64 start routine.

        This routine does not return. Only use JMP with this routine.
    \item [Example:]
        \begin{asmcode}
c64mode = $ff53

    jmp c64mode
        \end{asmcode}
\end{description}


% ****
% CHKIN
% ****

\newpage
\subsection{CHKIN}
\index{KERNAL Jump Table!CHKIN}
\label{KERNAL Jump Table!CHKIN}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FFC6
    \item [Description:] Set input channel
    \item [Inputs:]
    \item [Outputs:]
    \item [Remarks:]
    \item [Example:]
\end{description}


% ****
% CINT
% ****

\newpage
\subsection{CINT}
\index{KERNAL Jump Table!CINT}
\label{KERNAL Jump Table!CINT}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FF81
    \item [Description:] Initialize screen editor
    \item [Remarks:]
        CINT resets all properties of the screen editor, including indirect vectors, function key macros, VIC registers, and SID registers. It also clears the screen.

        CINT is typically called along with IOINIT, which resets additional properties of the screen editor.

        Because it updates indirect vectors, it must be called with IRQs disabled.
    \item [Example:]
        \begin{asmcode}
cint = $ff81

    sei
    jsr cint
    cli
        \end{asmcode}
\end{description}


% ****
% CIOUT
% ****

\newpage
\subsection{CIOUT}
\index{KERNAL Jump Table!CIOUT}
\label{KERNAL Jump Table!CIOUT}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FFA8
    \item [Description:] Serial: send a byte to listener
    \item [Inputs:]
    \item [Outputs:]
    \item [Remarks:]
    \item [Example:]
\end{description}


% ****
% CKOUT
% ****

\newpage
\subsection{CKOUT}
\index{KERNAL Jump Table!CKOUT}
\label{KERNAL Jump Table!CKOUT}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FFC9
    \item [Description:] Set output channel
    \item [Inputs:]
    \item [Outputs:]
    \item [Remarks:]
    \item [Example:]
\end{description}


% ****
% CLALL
% ****

\newpage
\subsection{CLALL}
\index{KERNAL Jump Table!CLALL}
\label{KERNAL Jump Table!CLALL}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FFE7
    \item [Description:] Close all files and channels
    \item [Inputs:]
    \item [Outputs:]
    \item [Remarks:]
    \item [Example:]
\end{description}


% ****
% CLOSE
% ****

\newpage
\subsection{CLOSE}
\index{KERNAL Jump Table!CLOSE}
\label{KERNAL Jump Table!CLOSE}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FFC3
    \item [Description:] Close logical file
    \item [Inputs:]
    \item [Outputs:]
    \item [Remarks:]
    \item [Example:]
\end{description}


% ****
% CLOSE\_ALL
% ****

\newpage
\subsection{CLOSE{\_}ALL}
\index{KERNAL Jump Table!CLOSE_ALL}
\label{KERNAL Jump Table!CLOSE_ALL}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FF50
    \item [Description:] Close all files on a device
    \item [Inputs:]
    \item [Outputs:]
    \item [Remarks:]
    \item [Example:]
\end{description}


% ****
% CLRCH
% ****

\newpage
\subsection{CLRCH}
\index{KERNAL Jump Table!CLRCH}
\label{KERNAL Jump Table!CLRCH}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FFCC
    \item [Description:] Restore default channels
    \item [Inputs:]
    \item [Outputs:]
    \item [Remarks:]
    \item [Example:]
\end{description}


% ****
% CMP\_FAR
% ****

\newpage
\subsection{CMP{\_}FAR}
\index{KERNAL Jump Table!CMP_FAR}
\label{KERNAL Jump Table!CMP_FAR}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FF7A
    \item [Description:] Compare a byte with an address in any bank
    \item [Inputs:]
        \textbf{A} Data to compare \\
        \textbf{X} Base page pointer \\
        \textbf{Y} Index from pointed address \\
        \textbf{Z} Bank
    \item [Outputs:]
        CPU status flags based on the comparison
    \item [Remarks:]
        Conceptually, this is the equivalent of \texttt{cmp (X),y} in bank Z.

        This can access any address in the first 1MB of memory. Unlike JMPFAR, this does not change the memory map. It uses a DMA job to access the long address.

        For the MEGA65, the 45GS02 supports an instruction that can do this with a 32-bit address stored on the base page, without the need for a KERNAL routine: \texttt{cmp [zp4],z}
    \item [Example:]
        \begin{asmcode}
cmp_far = $ff7a

    ; Compare memory at address 4.4502 to the accumulator
    lda #$00
    sta $fe
    lda #$45
    sta $ff
    ldx #$fe  ; base page pointer -> $4500
    ldy #$02  ; Y index
    ldz #$04  ; bank
    lda #$99  ; data to compare
    jsr cmp_far
    beq they_are_equal  ; ...
        \end{asmcode}

\end{description}


% ****
% GETIN
% ****

\newpage
\subsection{GETIN}
\index{KERNAL Jump Table!GETIN}
\label{KERNAL Jump Table!GETIN}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FFE4
    \item [Description:] Read a character from input device, buffered
    \item [Inputs:]
    \item [Outputs:]
    \item [Remarks:]
    \item [Example:]
\end{description}


% ****
% IOBASE
% ****

\newpage
\subsection{IOBASE}
\index{KERNAL Jump Table!IOBASE}
\label{KERNAL Jump Table!IOBASE}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FFF3
    \item [Description:] Report base address of I/O block
    \item [Outputs:]
        \textbf{X} Address low \\
        \textbf{Y} Address high
    \item [Remarks:]
        RESERVED. DO NOT USE.

        This is not used in the C65 KERNAL. As implemented, it returns \$D000, regardless of other settings.
    \item [Example:]
        \begin{asmcode}
iobase = $fff3

    jsr iobase
        \end{asmcode}
\end{description}


% ****
% IOINIT
% ****

\newpage
\subsection{IOINIT}
\index{KERNAL Jump Table!IOINIT}
\label{KERNAL Jump Table!IOINIT}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FF84
    \item [Description:] Initialize I/O devices
    \item [Remarks:]
        IOINIT resets the CIA chips, the 45GS02 port, the VIC chip, the UART, and the DOS.

        It must be called with IRQs disabled.
    \item [Example:]
    \begin{asmcode}
ioinit = $ff84

    sei
    jsr ioinit
    cli
    \end{asmcode}
\end{description}


% ****
% JMPFAR
% ****

\newpage
\subsection{JMPFAR}
\index{KERNAL Jump Table!JMPFAR}
\label{KERNAL Jump Table!JMPFAR}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JMP \$FF71
    \item [Description:] Jump to address in any bank
    \item [Inputs:]
        \textbf{\$02} Address bank (0-5) \\
        \textbf{\$03} Address high \\
        \textbf{\$04} Address low \\
        \textbf{\$05} CPU status register \\
        \textbf{\$06} CPU A register \\
        \textbf{\$07} CPU X register \\
        \textbf{\$08} CPU Y register \\
        \textbf{\$09} CPU Z register
    \item [Remarks:]
        This updates the CPU memory map to make a requested address visible as a 16-bit address, then JMPs to it. It does not return.

        This routine has similar restrictions as the \textbf{SYS} BASIC command, and cannot reach every address. It can only jump to addresses in non-zero banks from X.2000 -- X.7FFF.

        The revised memory map keeps \$0000--\$1FFF and \$8000--\$DFFF un-mapped (so they refer to bank 0 and I/O registers), and \$E000--\$FFFF mapped to KERNAL ROM.

        A program sets parameters to JMPFAR by writing to the KERNAL's base page. Parameters include the three address bytes, and the state of the CPU registers expected on entry to the new location.

        This routine does not return. Only use JMP to call this routine.
    \item [Example:]
        \begin{asmcode}
jmpfar = $ff71

    ; MAP $2000-$7FFF to bank 4, then JMP to 4.4500
    lda #$04
    sta $02
    lda #$45
    sta $03
    lda #$00
    sta $04
    lda #$04  ; Start routine with interrupts disabled
    sta $05
    jmp jmpfar
        \end{asmcode}
\end{description}


% ****
% JSRFAR
% ****

\newpage
\subsection{JSRFAR}
\index{KERNAL Jump Table!JSRFAR}
\label{KERNAL Jump Table!JSRFAR}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FF6E
    \item [Description:] Call subroutine in any bank
    \item [Inputs:]
        \textbf{\$02} Address bank (0-5) \\
        \textbf{\$03} Address high \\
        \textbf{\$04} Address low \\
        \textbf{\$05} CPU status register \\
        \textbf{\$06} CPU A register \\
        \textbf{\$07} CPU X register \\
        \textbf{\$08} CPU Y register \\
        \textbf{\$09} CPU Z register
    \item [Outputs:]
        CPU status, A, X, Y, and Z registers are as they were at the end of the subroutine.
    \item [Remarks:]
        This updates the CPU memory map to make a requested address visible as a 16-bit address, then JSRs to it. On return, it restores the previous KERNAL-managed memory map (e.g. the SYS map).

        This routine has similar restrictions as the \textbf{SYS} BASIC command, and cannot reach every address. It can only jump to addresses in non-zero banks from X.2000 -- X.7FFF.

        The revised memory map keeps \$0000--\$1FFF and \$8000--\$DFFF un-mapped (so they refer to bank 0 and I/O registers), and \$E000--\$FFFF mapped to KERNAL ROM.

        A program sets parameters to JSRFAR by writing to the KERNAL's base page. Parameters include the three address bytes, and the state of the CPU registers expected on entry to the new location.

        Only use JSR to call this routine.
    \item [Example:]
        \begin{asmcode}
jsrfar = $ff6e

    ; MAP $2000-$7FFF to bank 4, then JSR to 4.4500
    lda #$04
    sta $02
    lda #$45
    sta $03
    lda #$00
    sta $04
    lda #$04  ; Start routine with interrupts disabled
    sta $05
    jsr jsrfar

    ; Program continues...
        \end{asmcode}
\end{description}


% ****
% KEY
% ****

\newpage
\subsection{KEY}
\index{KERNAL Jump Table!KEY}
\label{KERNAL Jump Table!KEY}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FF9F
    \item [Description:] Perform a keyboard scan.
    \item [Remarks:]
        For the MEGA65, typing events are managed by a hardware buffer mechanism and not the KERNAL. A program that wants to consume a typing event can call GETIN, or access the typing event buffer registers directly, without calling KEY.

        KEY manages special keyboard behaviors, including Mega + Shift, No Scroll, and Ctrl-S. The MEGA65 KERNAL calls KEY in the KERNAL IRQ handler many times per second, similar to other Commodores. A program that disables the KERNAL IRQ handler but wants to maintain these behaviors can call KEY from a custom handler.

        \underline{NOTE}: For the MEGA65, KEY diverges from the C65 and does not offer vector hooks. Keyboard intercept vectors are a work in progress.
    \item [Example:]
        \begin{asmcode}
key = $ff9f

    jsr key
        \end{asmcode}
\end{description}


% ****
% LDA\_FAR
% ****

\newpage
\subsection{LDA{\_}FAR}
\index{KERNAL Jump Table!LDA_FAR}
\label{KERNAL Jump Table!LDA_FAR}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FF74
    \item [Description:] Read a byte from an address in any bank
    \item [Inputs:]
        \textbf{X} Base page pointer \\
        \textbf{Y} Index from pointed address \\
        \textbf{Z} Bank
    \item [Outputs:]
        \textbf{A} The value at the address
    \item [Remarks:]
        Conceptually, this is the equivalent of \texttt{lda (X),y} in bank Z.

        This can access any address in the first 1MB of memory. Unlike JMPFAR, this does not change the memory map. It uses a DMA job to access the long address.

        For the MEGA65, the 45GS02 supports an instruction that can do this with a 32-bit address stored on the base page, without the need for a KERNAL routine: \texttt{lda [zp4],z}
    \item [Example:]
        \begin{asmcode}
lda_far = $ff74

    ; Load memory at address 4.4502 into the accumulator
    lda #$00
    sta $fe
    lda #$45
    sta $ff
    ldx #$fe  ; base page pointer -> $4500
    ldy #$02  ; Y index
    ldz #$04  ; bank
    jsr lda_far
        \end{asmcode}

\end{description}


% ****
% LISTN
% ****

\newpage
\subsection{LISTN}
\index{KERNAL Jump Table!LISTN}
\label{KERNAL Jump Table!LISTN}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FFB1
    \item [Description:] Serial: send ``listen'' command (see CKOUT)
    \item [Inputs:]
    \item [Outputs:]
    \item [Remarks:]
    \item [Example:]
\end{description}


% ****
% LKUPLA
% ****

\newpage
\subsection{LKUPLA}
\index{KERNAL Jump Table!LKUPLA}
\label{KERNAL Jump Table!LKUPLA}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FF5F
    \item [Description:] Search for logical file number in use
    \item [Inputs:]
    \item [Outputs:]
    \item [Remarks:]
    \item [Example:]
\end{description}


% ****
% LKUPSA
% ****

\newpage
\subsection{LKUPSA}
\index{KERNAL Jump Table!LKUPSA}
\label{KERNAL Jump Table!LKUPSA}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FF62
    \item [Description:] Search for secondary address in use
    \item [Inputs:]
    \item [Outputs:]
    \item [Remarks:]
    \item [Example:]
\end{description}


% ****
% LOAD
% ****

\newpage
\subsection{LOAD}
\index{KERNAL Jump Table!LOAD}
\label{KERNAL Jump Table!LOAD}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FFD5
    \item [Description:] Load/verify from file
    \item [Inputs:]
    \item [Outputs:]
    \item [Remarks:]
    \item [Example:]
\end{description}


% ****
% MEMBOT
% ****

\newpage
\subsection{MEMBOT}
\index{KERNAL Jump Table!MEMBOT}
\label{KERNAL Jump Table!MEMBOT}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FF9C
    \item [Description:] Read/set bottom of system RAM
    \item [Inputs:]
        To set: \\
        \textbf{C flag} = 0 \\
        \textbf{X} Address low \\
        \textbf{Y} Address high

        To read: \\
        \textbf{C flag} = 1
    \item [Outputs:]
        When reading: \\
        \textbf{X} Address low \\
        \textbf{Y} Address high
    \item [Remarks:]
        RESERVED. DO NOT USE.

        This is not useful. The C65 KERNAL does not use the ``memory size'' variable. This routine was included in the C65 KERNAL for completeness.
    \item [Example:]
        \begin{asmcode}
membot = $ff9c

    clc
    ldx #$00
    ldy #$20
    jsr membot

    sec
    jsr membot
        \end{asmcode}
\end{description}


% ****
% MEMTOP
% ****

\newpage
\subsection{MEMTOP}
\index{KERNAL Jump Table!MEMTOP}
\label{KERNAL Jump Table!MEMTOP}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FF99
    \item [Description:] Read/set top of system RAM
    \item [Inputs:]
        To set: \\
        \textbf{C flag} = 0 \\
        \textbf{X} Address low \\
        \textbf{Y} Address high

        To read: \\
        \textbf{C flag} = 1
    \item [Outputs:]
        When reading: \\
        \textbf{X} Address low \\
        \textbf{Y} Address high
    \item [Remarks:]
        RESERVED. DO NOT USE.

        This is not useful. The C65 KERNAL does not use the ``memory size'' variable. This routine was included in the C65 KERNAL for completeness.
    \item [Example:]
        \begin{asmcode}
memtop = $ff99

    clc
    ldx #$00
    ldy #$ff
    jsr memtop

    sec
    jsr memtop
        \end{asmcode}
\end{description}


% ****
% MONEXIT
% ****

\newpage
\subsection{MONEXIT}
\index{KERNAL Jump Table!MONEXIT}
\label{KERNAL Jump Table!MONEXIT}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JMP \$FFA2
    \item [Description:] Monitor's exit to BASIC
    \item [Remarks:]
        This is only used by the monitor, and is not useful to programs.
    \item [Example:]
        \begin{asmcode}
monexit = $ffa2

    jmp monexit
        \end{asmcode}

\end{description}


% ****
% MonitorCall
% ****

\newpage
\subsection{MonitorCall}
\index{KERNAL Jump Table!MonitorCall}
\label{KERNAL Jump Table!MonitorCall}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JMP \$FF56
    \item [Description:] Invoke monitor
    \item [Remarks:]
        This stops the program, then invokes the monitor.

        This routine does not return. Only use JMP to call this routine.

        When the monitor exits, it returns to the \texttt{READY.} prompt.
    \item [Example:]
        \begin{asmcode}
monitor_call = $ff56

    jmp monitor_call
        \end{asmcode}
\end{description}


% ****
% OPEN
% ****

\newpage
\subsection{OPEN}
\index{KERNAL Jump Table!OPEN}
\label{KERNAL Jump Table!OPEN}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FFC0
    \item [Description:] Open logical file
    \item [Inputs:]
    \item [Outputs:]
    \item [Remarks:]
    \item [Example:]
\end{description}


% ****
% PFKEY
% ****

\newpage
\subsection{PFKEY}
\index{KERNAL Jump Table!PFKEY}
\label{KERNAL Jump Table!PFKEY}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FF68
    \item [Description:] Program an editor function key
    \item [Inputs:]
        \textbf{A} Base page pointer to string address (lo/hi/bank) \\
        \textbf{X} Function key number (1-16) \\
        \textbf{Y} String length
    \item [Outputs:]
        \textbf{C flag} Set if the update failed
    \item [Remarks:]
        The screen editor supports user-defined macros associated with function keys. The PFKEY call updates a macro's definition, similar to the \textbf{KEY} BASIC command.

        As input, the program sets the accumulator to a base page address that contains the 24-bit address of the macro string, in little-endian format. The Y register is the string's length, up to 240 characters.

        The X register is the key to define: 1 -- 14 for the corresponding numbered function key, 15 for the Help key, and 16 for the Stop (Shift + Run/Stop) key.

        The string contains the PETSCII codes that the macro will type when executed. This is unlike the BASIC string expression that you would use with the \textbf{KEY} command: special characters like double-quotes must appear as PETSCII codes in the string used with PFKEY. (See the example below.)

        If successful, PFKEY copies the string into macro memory, and does not need the string at the provided address to persist.
    \item [Example:]
        \begin{asmcode}
pfkey = $ff68

    ; Store string address in base page $fd-$ff
    lda #<macro
    sta $fd
    lda #>macro
    sta $fe
    lda #0
    sta $ff

    ; Install macro string for F6 key
    lda #$fd
    ldy #macro_end-macro
    ldx #6
    jsr pfkey

    rts

macro:
    !pet "print ",34,"it works!",34,13
macro_end:
        \end{asmcode}
\end{description}


% ****
% PHOENIX
% ****

\newpage
\subsection{PHOENIX}
\index{KERNAL Jump Table!PHOENIX}
\label{KERNAL Jump Table!PHOENIX}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JMP \$FF5C
    \item [Description:] Call disk boot loader
    \item [Remarks:]
        See BOOT\_SYS for a description of boot disks.

        Some early Commodore 65 prototype ROMs replaced this routine with one that performed diagnostics and printed results. Later versions replaced this with a call to the boot sequence.

        This routine does not return. Only use JMP with this routine.

        \underline{NOTE}: For the MEGA65, this feature is untested.

    \item [Example:]
        \begin{asmcode}
phoenix = $ff5c

    jmp phoenix
        \end{asmcode}

\end{description}


% ****
% PLOT
% ****

\newpage
\subsection{PLOT}
\index{KERNAL Jump Table!PLOT}
\label{KERNAL Jump Table!PLOT}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FFF0
    \item [Description:] Read/set cursor position
    \item [Inputs:]
        To set: \\
        \textbf{C flag} = 0 \\
        \textbf{X} Cursor line \\
        \textbf{Y} Cursor column

        To read: \\
        \textbf{C flag} = 1
    \item [Outputs:]
        When setting: \\
        \textbf{C flag} Set on error

        When reading: \\
        \textbf{X} Cursor line \\
        \textbf{Y} Cursor column
    \item [Remarks:]
        The cursor position is relative to the active window. Use SCRORG to read the current window size.

        When setting, if the requested position is outside the active window, the routine returns with the Carry flag set.
    \item [Example:]
        \begin{asmcode}
plot = $fff0
primm = $ff7d

    ; Move the cursor to the 78th column of the 3rd row
    clc
    ldy #77
    ldx #2
    jsr plot

    jsr primm
    !pet "message",0

    ; Read the new cursor position
    sec
    jsr plot
    stx $1600
    sty $1601
        \end{asmcode}
\end{description}


% ****
% PRIMM
% ****

\newpage
\subsection{PRIMM}
\index{KERNAL Jump Table!PRIMM}
\label{KERNAL Jump Table!PRIMM}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FF7D
    \item [Description:] Print an inline null-terminated short string.
    \item [Remarks:]
        The string to print immediately follows the JSR instruction in memory.

        The string must end in a null (0) byte, and must be at most 255 bytes in length including the null byte.

        Characters are written to the output stream, as with BSOUT.

        Only use JSR to call PRIMM.

        PRIMM preserves registers. This makes it suitable for dropping in the middle of a program temporarily for troubleshooting purposes.
    \item [Example:]
        \begin{asmcode}
primm = $ff7d

    jsr primm
    !pet "this is a petscii string to print.",0

    ; Program continues...
        \end{asmcode}
\end{description}


% ****
% RAMTAS
% ****

\newpage
\subsection{RAMTAS}
\index{KERNAL Jump Table!RAMTAS}
\label{KERNAL Jump Table!RAMTAS}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FF87
    \item [Description:] Initialize RAM and buffers
    \item [Remarks:]
        RAMTAS resets KERNAL base page variables, and resets pointers to the top and bottom of system RAM.

        This is primarily for use by the system start-up and reset sequences. A machine code program executed from a BASIC bootstrap program cannot cleanly return to BASIC after calling RAMTAS, nor can RAMTAS be called from the monitor.
    \item [Example:]
        \begin{asmcode}
ramtas = $ff87

    jsr ramtas
        \end{asmcode}
\end{description}


% ****
% RDTIM
% ****

\newpage
\subsection{RDTIM}
\index{KERNAL Jump Table!RDTIM}
\label{KERNAL Jump Table!RDTIM}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FFDE
    \item [Description:] Read CIA1 24-hour clock
    \item [Outputs:]
        \textbf{Y} Hours, 0-23, in BCD \\
        \textbf{X} Minutes, 0-59, in BCD \\
        \textbf{A} Seconds, 0-59, in BCD \\
        \textbf{Z} Tenths of a second, 0-9
    \item [Remarks:]
        This reads the time-of-day (TOD) clock feature of the CIA1 device. This clock counts tenths of seconds, and maintains hours, minutes, seconds, and tenths of seconds.

        Use SETTIM to set the value of the TOD clock.

        For the MEGA65, the CIA1 TOD clock has no relationship to the battery-backed Real-Time Clock (RTC). The value returned by RDTIM is the CIA1 TOD value, not the RTC value. BASIC 65's TI\$ and DT\$ special variables use the RTC, and not the TOD.

        Values are in Binary Coded Decimal format, where each nibble represents a decimal digit. For example, when RDTIM returns the hexadecimal value \$59 in the accumulator, this represents a value of 59 (decimal) seconds.
    \item [Example:]
        \begin{asmcode}
rdtim = $ffde
bsout = $ffd2

    ; Print hours and minutes, as HH:MM
    jsr rdtim
    tya
    jsr print_bcd
    lda #':'
    jsr bsout
    txa
    jsr print_bcd
    rts

print_bcd:
    pha
    lsr
    lsr
    lsr
    lsr
    adc #'0'
    jsr bsout
    pla
    and #$0f
    adc #'0'
    jsr bsout
    rts
        \end{asmcode}
\end{description}


% ****
% READSS
% ****

\newpage
\subsection{READSS}
\index{KERNAL Jump Table!READSS}
\label{KERNAL Jump Table!READSS}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FFB7
    \item [Description:] Get status of last I/O operation
    \item [Inputs:]
    \item [Outputs:]
    \item [Remarks:]
    \item [Example:]
\end{description}


% ****
% RESTOR
% ****

\newpage
\subsection{RESTOR}
\index{KERNAL Jump Table!RESTOR}
\label{KERNAL Jump Table!RESTOR}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FF8A
    \item [Description:] Initialize KERNAL vector table
    \item [Remarks:]
        This resets all KERNAL-related vectors to their default values, pointing to routines in ROM.

        It does not reset vectors used by the screen editor and BASIC.

        It must be called with interrupts disabled.

        See VECTOR.
    \item [Example:]
    \begin{asmcode}
restor = $ff8a

    sei
    jsr restor
    cli
    \end{asmcode}
\end{description}


% ****
% SAVE
% ****

\newpage
\subsection{SAVE}
\index{KERNAL Jump Table!SAVE}
\label{KERNAL Jump Table!SAVE}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FFD8
    \item [Description:] Save to file
    \item [Inputs:]
    \item [Outputs:]
    \item [Remarks:]
    \item [Example:]
\end{description}


% ****
% ScanStopKey
% ****

\newpage
\subsection{ScanStopKey}
\index{KERNAL Jump Table!ScanStopKey}
\label{KERNAL Jump Table!ScanStopKey}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FFEA
    \item [Description:] Scan Stop key
    \item [Outputs:]
        \textbf{A} \$7F if the Stop key is pressed, \$FF otherwise \\
        \textbf{N flag} Clear if the Stop key is pressed, set otherwise
    \item [Remarks:]
        Unlike STOP, ScanStopKey does not invoke the \texttt{istop} vector, and does not close channels or flush the keyboard buffer.
    \item [Example:]
        \begin{asmcode}
scan_stop_key = $ffea

    ; Wait for Stop key
-   jsr scan_stop_key
    bmi -
        \end{asmcode}
\end{description}


% ****
% SCRORG
% ****

\newpage
\subsection{SCRORG}
\index{KERNAL Jump Table!SCRORG}
\label{KERNAL Jump Table!SCRORG}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FFED
    \item [Description:] Get current screen window size
    \item [Outputs:]
        \textbf{C flag} Text screen width: 0=80, 1=40 \\
        \textbf{X} Window width \\
        \textbf{Y} Window height \\
        \textbf{A} Window top-left screen memory address, low \\
        \textbf{Z} Window top-left screen memory address, high
    \item [Remarks:]
        The screen editor maintains a ``window,'' a rectangle on the text screen, where terminal output is written and input is accepted. The window size and position defaults to the full screen, and can be adjusted with the \textbf{WINDOW} BASIC command.

        SCRORG returns properties of this window that can be used to plot characters in screen memory.
    \item [Example:]
        \begin{asmcode}
scrorg = $ffed

    ; Plot a spade glyph in the top left corner
    ; of the active window.
    jsr scrorg
    sta $fe
    stz $ff
    lda #65
    ldy #0
    sta ($fe),y
        \end{asmcode}

\end{description}


% ****
% SECND
% ****

\newpage
\subsection{SECND}
\index{KERNAL Jump Table!SECND}
\label{KERNAL Jump Table!SECND}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FF93
    \item [Description:] Serial: send secondary address to listener
    \item [Inputs:]
    \item [Outputs:]
    \item [Remarks:]
    \item [Example:]
\end{description}


% ****
% SETBNK
% ****

\newpage
\subsection{SETBNK}
\index{KERNAL Jump Table!SETBNK}
\label{KERNAL Jump Table!SETBNK}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FF6B
    \item [Description:] Set bank for I/O and filename memory
    \item [Inputs:]
    \item [Outputs:]
    \item [Remarks:]
    \item [Example:]
\end{description}


% ****
% SETLFS
% ****

\newpage
\subsection{SETLFS}
\index{KERNAL Jump Table!SETLFS}
\label{KERNAL Jump Table!SETLFS}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FFBA
    \item [Description:] Set file, device, secondary address
    \item [Inputs:]
    \item [Outputs:]
    \item [Remarks:]
    \item [Example:]
\end{description}


% ****
% SETMSG
% ****

\newpage
\subsection{SETMSG}
\index{KERNAL Jump Table!SETMSG}
\label{KERNAL Jump Table!SETMSG}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FF90
    \item [Description:] Enable/disable KERNAL messages
    \item [Inputs:]
        \textbf{A} bit 7 = control messages, bit 6 = error messages
    \item [Remarks:]
        The KERNAL can print messages to the screen when performing disk operations, such as ``LOADING,'' ``SAVING,'' ``VERIFYING,'' and ``I/O ERROR.'' These are disabled by default.

        To enable KERNAL control messages, set bit 7. To enable KERNAL I/O error messages, set bit 6.

        KERNAL messages are not the same as those output by BASIC.
    \item [Example:]
        \begin{asmcode}
setmsg = $ff90

    ; Enable all KERNAL messages
    lda #$c0
    jsr setmsg
        \end{asmcode}

\end{description}


% ****
% SETNAM
% ****

\newpage
\subsection{SETNAM}
\index{KERNAL Jump Table!SETNAM}
\label{KERNAL Jump Table!SETNAM}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FFBD
    \item [Description:] Set filename pointers
    \item [Inputs:]
    \item [Outputs:]
    \item [Remarks:]
    \item [Example:]
\end{description}


% ****
% SETTIM
% ****

\newpage
\subsection{SETTIM}
\index{KERNAL Jump Table!SETTIM}
\label{KERNAL Jump Table!SETTIM}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FFDB
    \item [Description:] Set CIA1 24-hour clock
    \item [Inputs:]
        \textbf{Y} Hours, 0-23, in BCD \\
        \textbf{X} Minutes, 0-59, in BCD \\
        \textbf{A} Seconds, 0-59, in BCD \\
        \textbf{Z} Tenths of a second, 0-9
    \item [Remarks:]
        This sets the time-of-day (TOD) clock feature of the CIA1 device. This clock counts tenths of seconds, and maintains hours, minutes, seconds, and tenths of seconds.

        Use RDTIM to read the current value of the TOD clock.

        For the MEGA65, the CIA1 TOD clock has no relationship to the battery-backed Real-Time Clock (RTC). Setting the TOD clock does not affect the RTC. BASIC 65's TI\$ and DT\$ special variables use the RTC, and not the TOD.

        Values are in Binary Coded Decimal format, where each nibble represents a decimal digit. For example, to set the seconds value to 59 seconds, use the hexadecimal value \$59.
    \item [Example:]
        \begin{asmcode}
settim = $ffdb

    ; Set the TOD clock to 14:30:57.5
    ; (aka 2:30:57.5 PM)
    ldy #$14
    ldx #$30
    lda #$57
    ldz #$05
    jsr settim
        \end{asmcode}
\end{description}


% ****
% SPIN\_SPOUT
% ****

\newpage
\subsection{SPIN{\_}SPOUT}
\index{KERNAL Jump Table!SPIN_SPOUT}
\label{KERNAL Jump Table!SPIN_SPOUT}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FF4D
    \item [Description:] Set up fast serial ports
    \item [Inputs:]
    \item [Outputs:]
    \item [Remarks:]
    \item [Example:]
\end{description}


% ****
% STA\_FAR
% ****

\newpage
\subsection{STA{\_}FAR}
\index{KERNAL Jump Table!STA_FAR}
\label{KERNAL Jump Table!STA_FAR}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FF77
    \item [Description:] Store a byte to an address in any bank
    \item [Inputs:]
        \textbf{A} Data to store \\
        \textbf{X} Base page pointer \\
        \textbf{Y} Index from pointed address \\
        \textbf{Z} Bank
    \item [Remarks:]
        Conceptually, this is the equivalent of \texttt{sta (X),y} in bank Z.

        This can access any address in the first 1MB of memory. Unlike JMPFAR, this does not change the memory map. It uses a DMA job to access the long address.

        For the MEGA65, the 45GS02 supports an instruction that can do this with a 32-bit address stored on the base page, without the need for a KERNAL routine: \texttt{sta [zp4],z}
    \item [Example:]
            \begin{asmcode}
sta_far = $ff77

    ; Store value to address 4.4502
    lda #$00
    sta $fe
    lda #$45
    sta $ff
    ldx #$fe  ; base page pointer -> $4500
    ldy #$02  ; Y index
    ldz #$04  ; bank
    lda #$99  ; the value to store
    jsr sta_far
            \end{asmcode}

\end{description}


% ****
% STOP
% ****

\newpage
\subsection{STOP}
\index{KERNAL Jump Table!STOP}
\label{KERNAL Jump Table!STOP}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FFE1
    \item [Description:] Report Stop key, and reset I/O if pressed
    \item [Outputs:]
        \textbf{Z flag} Set if Stop is pressed
    \item [Remarks:]
        If the Stop key (Shift + Run/Stop) was pressed in the most recent call to ScanStopKey, STOP sets the Zero (Z) flag, closes all active channels, and flushes the keyboard queue. ScanStopKey is called routinely by the KERNAL, or can be called explicitly by the program if the KERNAL is disabled.

        This behavior can be overridden or extended with the \texttt{istop} vector.

        To test for the Stop key without side effects, see ScanStopKey.
    \item [Example:]
        \begin{asmcode}
stop = $ffe1

    ; Wait for the Stop key
-   jsr stop
    bne -
        \end{asmcode}
\end{description}


% ****
% SWAPPER
% ****

\newpage
\subsection{SWAPPER}
\index{KERNAL Jump Table!SWAPPER}
\label{KERNAL Jump Table!SWAPPER}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FF65
    \item [Description:] Toggle between 40x25 and 80x25 text modes
    \item [Remarks:]
        This does not yet support 80x50 text mode.
    \item [Example:]
swapper = \$ff65

    jsr swapper
\end{description}


% ****
% TALK
% ****

\newpage
\subsection{TALK}
\index{KERNAL Jump Table!TALK}
\label{KERNAL Jump Table!TALK}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FFB4
    \item [Description:] Serial: send ``talk'' command (see CHKIN)
    \item [Inputs:]
    \item [Outputs:]
    \item [Remarks:]
    \item [Example:]
\end{description}


% ****
% TKSA
% ****

\newpage
\subsection{TKSA}
\index{KERNAL Jump Table!TKSA}
\label{KERNAL Jump Table!TKSA}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FF96
    \item [Description:] Serial: send secondary address to talker
    \item [Inputs:]
    \item [Outputs:]
    \item [Remarks:]
    \item [Example:]
\end{description}


% ****
% UNLSN
% ****

\newpage
\subsection{UNLSN}
\index{KERNAL Jump Table!UNLSN}
\label{KERNAL Jump Table!UNLSN}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FFAE
    \item [Description:] Serial: send ``unlisten'' command (see CLRCH)
    \item [Inputs:]
    \item [Outputs:]
    \item [Remarks:]
    \item [Example:]
\end{description}


% ****
% UNTLK
% ****

\newpage
\subsection{UNTLK}
\index{KERNAL Jump Table!UNTLK}
\label{KERNAL Jump Table!UNTLK}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FFAB
    \item [Description:] Serial: send ``untalk'' command (see CLRCH)
    \item [Inputs:]
    \item [Outputs:]
    \item [Remarks:]
    \item [Example:]
\end{description}


% ****
% VECTOR
% ****

\newpage
\subsection{VECTOR}
\index{KERNAL Jump Table!VECTOR}
\label{KERNAL Jump Table!VECTOR}
\begin{description}[leftmargin=2cm,style=nextline]
    \item [Address:] JSR \$FF8D
    \item [Description:] Read/set KERNAL vector table
    \item [Inputs:]
        To read: \\
        \textbf{C flag} = 1 \\
        \textbf{X} Destination address, low \\
        \textbf{Y} Destination address, high

        To set: \\
        \textbf{C flag} = 0 \\
        \textbf{X} Source address, low \\
        \textbf{Y} Source address, high

    \item [Remarks:]
        A program can override or extend some behaviors of the KERNAL, screen editor, and BASIC by installing a set of addresses of custom routines, known as \emph{vectors}. By default, KERNAL vectors point to routines in ROM.

        To install new vectors:

        \begin{enumerate}
            \item Use VECTOR to copy the existing vector addresses to a location in memory.
            \item As needed, copy the original vector address into the custom routine's code, such as to return control to the original KERNAL routine after performing a custom action.
            \item Write the custom routine's address into the vector table in memory.
            \item Use VECTOR to install the updated vector addresses.
        \end{enumerate}

        \underline{NOTE}: The KERNAL uses a memory map for BASIC that hides most program memory from the CPU. Custom routines must live in the range \$1600 -- \$1EFF to be visible when BASIC and the screen editor are running.

        Some Commodore programmers are accustomed to reading and writing custom vector addresses directly from internal KERNAL memory, without using the VECTOR routine. For the MEGA65, it is important for programs to use the VECTOR accessor routine, and to not depend on the internal KERNAL memory location, to assure compatibility with future versions of the ROM.

        Use RESTOR to reset the vector table to the KERNAL defaults.

    \item [Example:]
        \begin{asmcode}
vector = $ff8d

    ; Install custom_irq routine to $1600,
    ; so that it will be visible when BASIC
    ; is active.
    ldx #custom_irq_end-custom_irq+1
-   lda custom_irq-1,x
    sta $1600-1,x
    dex
    bne -

    ; Read vector table into memory
    sec
    ldx #<vectable
    ldy #>vectable
    jsr vector

    ; Copy the iirq vector to custom_irq's
    ; jmp instruction
    lda vectable
    sta $1600+custom_irq_return-custom_irq+1
    lda vectable+1
    sta $1600+custom_irq_return-custom_irq+2

    ; Write custom_irq address to iirq
    lda #$00
    sta vectable
    lda #$16
    sta vectable+1

    ; Install updated vector table
    clc
    ldx #<vectable
    ldy #>vectable
    jsr vector

    ; Return to BASIC
    rts

custom_irq:
    ; Rotate the top left character
    inc $0800
custom_irq_return:
    jmp $0000
custom_irq_end:

vectable:
    ; See vector table documentation for the
    ; table size
    !fill $1f
        \end{asmcode}

\end{description}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
